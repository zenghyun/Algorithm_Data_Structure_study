## 프로그램의 성능 측정 방법 

일반적으로 연산 횟수가 10억을 넘어가면 1초 이상의 시간이 소요된다. 

[예시] n이 1,000일 때를 고려해 보자.

- O(n) : 약 1,000번의 연산

- O(nlogn) : 약 10,000번의 연산

- O(n<sup>2</sup>) : 약 1,000,000번의 연산

- O(n<sup>3</sup>) : 약 1,000,000,000번의 연산 

###  Big-O 표기법으로 시간 복잡도를 표기할 때는 가장 큰 항만을 표시한다. 
현실 세계에서는 동작 시간이 1초 이내인 알고리즘을 설계할 필요가 있다.

### 자료구조를 적절히 활용하기
자료구조의 종류로는 스택, 큐, 트리 등이 있다.
프로그램을 작성할 때는 자료구조를 적절히 활용하여 시간 복잡도를 최소화하여야 한다. 

## 배열과 리스트 알아보기 

### 배열의 특징
컴퓨터의 메인 메모리에서 배열의 공간은 연속적으로 할당된다.

장점: 캐시(cache) 히트 가능성이 높으며, 조회가 빠르다.

단점: 배열의 크기를 미리 지정해야 하는 것이 일반적이므로, 데이터의 추가 및 삭제에 한계가 있다. 

### JavaScript의 배열
- JavaScript의 배열 자료형은 동적 배열이다.
- 배열의 용량이 가득 차면, 자동으로 크기를 증가시킨다.
- 내부적으로 포인터(pointer)를 사용하여, 연결 리스트의 장점도 가지고 있다.
- 배열(array) 혹은 스택(stack)의 기능이 필요할 때 사용할 수 있다.
  
[참고] 큐(queue)의 기능을 제공하지 못한다. 

### 크기가 N X M인 2차원 리스트(배열) 만들기
- 최신 JavaScript 환경 (ES6 이상)에서 사용할 수 있는 문법이다.
- 한 줄로 2차원 배열을 초기화 할 수 있다. 
- 배열의 각 원소에 크기가 5인 배열을 할당한다.

```javascript
let arr = Array.from(Array(4), () => new Array(5));

console.log(arr);

// 결과 

/*
[
    [ <5 empty items>],
    [ <5 empty items>],
    [ <5 empty items>],
    [ <5 empty items>],
]
*/

// 예시 
// 반복문을 이용해 배열 초기화
let arr2 = new Array(3);
for (let i = 0; i < arr2.length; i++) {
    arr2[i] = Array.from( {length:4}, (undefined, j) => i * 4 + j);
}
console.log(arr2);

```

### 연결 리스트
연결 리스트는 컴퓨터의 메인 메모리상에서 주소가 연속적이지 않다.
배열과 다르게 크기가 정해져 있지 않고, 리스트의 크기는 동적으로 변경이 가능하다.

장점: 포인터(pointer)를 통해 다음 데이터의 위치를 가리킨다는 점에서 삽입과 삭제가 간편하다. 
단점: 특정 번째 원소를 검색할 때는 앞에서부터 원소를 찾아야 하므로, 데이터의 검색 속도가 느리다. 

연결 리스트는 각 노드가 한 줄로 연결되어 있는 자료 구조다.
각 노드는 (데이터, 포인터) 형태를 가진다.

포인터: 다음 노드의 메모리 주소를 가리키는 목적으로 사용된다. 

연결성: 각 노드의 포인터는 다음 혹은 이전 노드를 가리킨다. 

- 연결 리스트를 이용하면 다양한 자료구조를 구현할 수 있다. 
- 예시) 스택, 큐 등
- JavaScript는 연결 리스트를 활용하는 자료구조를 제공한다.
- 그래서 연결 리스트를 실제 구현해야 하는 경우는 적지만, 그 원리에 대해서 이해해 보자. 

<br>

## 연결 리스트 (Linked List) vs 배열(Array) 
- 연결 리스트와 배열(array)을 비교하여 장단점을 이해할 수 있다.
- 특정 위치의 데이터를 삭제할 때, 일반적인 배열에서는 O(N)만큼의 시간이 소요된다.
- 하지만, 연결 리스트를 이용하면 단순히 연결만 끊어주면 된다.
- 따라서 삭제할 위치를 정확히 알고 있는 경우 O(1)의 시간이 소요된다. 